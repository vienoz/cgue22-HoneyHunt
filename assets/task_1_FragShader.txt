#version 430 core

layout (location=3)uniform sampler2D colorTexture; 
layout (location=9)uniform sampler2D specularT;
layout (location=6)uniform vec3 viewPos;
vec3 objColor;
vec3 weirdSpecularVariableFromSpecMap;

//light
layout (location=4)uniform vec3 lightColor;	//DONE
layout (location=5)uniform vec3 lightPos;	//DONE
layout (location=11)uniform float constant;
layout (location=12)uniform float linear;
layout (location=13)uniform float quadratic;

//directional light
layout (location=14)uniform vec3 directionColor;      //DONE
layout (location=15)uniform vec3 directionDirection;   //DONE

//spotlight
layout (location=18)uniform vec3 spotPos;
layout (location=16)uniform float cutOff; 
layout (location=17)uniform vec3 spotDirection; 
layout (location=19)uniform float outerCutOff; 
layout (location=20)uniform bool displaySpot; 

vec3 calcDirLight(vec3 viewDir, vec3 normal); 
vec3 CalcPointLight(vec3 norma,  vec3 viewDir);  
vec3 CalcSpotLight(vec3 norm, vec3 viewDir);

//materials
layout (location=7)uniform vec3 ambient;    	//DONE als materialCoeff vec3
layout (location=8)uniform vec3 diffuse;	//DONE als materialCoeff vec3
layout (location=10)uniform float shininess;	//DONE als materialCoeff vec3

in vec3 normals; 
in vec3 fragPos;
in vec2 uv;

layout (location=0) out vec4 fragColor; // result color of the pixel





void main()
{
      objColor =                         vec3(texture(colorTexture, uv).rgb);
      weirdSpecularVariableFromSpecMap = vec3(texture(specularT, uv).rgb);
      vec3 norm = normalize(normals);              


      vec3 viewDir = normalize(viewPos - fragPos);     

      vec3 result = vec3(1.0f, 0.4f, 0.1f);

      result = calcDirLight(viewDir, norm);

      if(displaySpot == true){
      result += CalcSpotLight(norm, viewDir);
      }
     
      result += CalcPointLight(norm, viewDir);

       fragColor= vec4(result, 1.0f); //insert normals for fun
      //fragColor= vec4(1.0f, 0.4f, 0.1f, 1.0f); //testing 
}


vec3 calcDirLight(vec3 viewDir, vec3 norma){
     vec3 ambient = directionColor * ambient;

      vec3 lightDir = normalize(-directionDirection);
      float diff= max(dot(norma, lightDir), 0.0f);

      vec3 diffuse = directionColor * (diffuse * diff);
      vec3 reflectDir = reflect(-lightDir, norma);

     float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess); //difference between view direction and reflection direction
     vec3 specular =  directionColor * spec * weirdSpecularVariableFromSpecMap; 

    return (ambient+ diffuse) * objColor + specular;
}

vec3 CalcPointLight(vec3 norma,  vec3 viewDir){
    
    vec3 ambient = lightColor * ambient;

    vec3 lightDir = normalize(lightPos - fragPos);

    float diff = max(dot(norma, lightDir), 0.0);
    vec3 diffuse = lightColor * (diffuse * diff);

    vec3 reflectDir = reflect(-lightDir, norma);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
    vec3 specular =  lightColor * weirdSpecularVariableFromSpecMap * spec; 

    float distance = length(lightPos - fragPos);
    float attenuation = 1.0 / (constant + linear * distance + quadratic * (distance * distance));
  

   ambient *= attenuation; // not neccessary
   diffuse *= attenuation;
   specular *= attenuation;

   return (ambient+ diffuse) * objColor + specular;
}

vec3 CalcSpotLight(vec3 norma, vec3 viewDir){


    vec3 lightDir = normalize(spotPos - fragPos);
    float theta = dot(lightDir, normalize(-spotDirection));
    float epsilon = (cutOff - outerCutOff);

    float intense = clamp((theta - outerCutOff)/ epsilon , 0.0, 1.0);


        //diffuse
       float diff = max(dot(norma, lightDir), 0.0);
       vec3 diffuse = lightColor * (diffuse * diff);

       //spec
       vec3 reflectDir = reflect(-lightDir, norma);
       float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
       vec3 specular =  lightColor * weirdSpecularVariableFromSpecMap * spec;


        diffuse  *= intense;
        specular *= intense;

        float distance = length(lightPos - fragPos);
        float attenuation = 1.0 / (constant + linear * distance + quadratic * (distance * distance));
        diffuse *= attenuation;
        specular *= attenuation;
  
       return ( diffuse) * objColor + specular;
}